# assign variables
SCRIPTNAME=$(basename "${0}")
SCRIPTDIR=$(dirname "${0}")

OBJECTS_FIND_EXCLUSIONS=(! -name ".*")
OBJECTS_FIND_EXCLUSIONS+=(! -path "*/access/*")
OBJECTS_FIND_EXCLUSIONS+=(! -path "*/captions/*")
OBJECTS_FIND_EXCLUSIONS+=(! -path "*/reformatted/*")
OBJECTS_FIND_EXCLUSIONS+=(! -path "*/service/*")
OBJECTS_FIND_EXCLUSIONS+=(! -path "*/trimmed_materials/*")

# load configuration file
if [ -f "${TEMP_MMCONFIG}" ] ; then
    # for use in ingestfiletest; prevents test files from going to permanent storage
    MM_CONFIG_FILE="${TEMP_MMCONFIG}"
else
    MM_CONFIG_FILE="${SCRIPTDIR}/mm.conf"
fi
if [ -f "${MM_CONFIG_FILE}" ] ; then
    . "${MM_CONFIG_FILE}"
elif [ ! "${CONFIG}" = "Y" -a "${REQUIRECONFIG}" = "Y" ] ; then
    echo "The configuration file is not set. You must first create ${MM_CONFIG_FILE} by running mmconfig." 1>&2
    exit 1
fi

_check_for_lto_md5_flags(){
    if [ -z "${LTO_MD5_FLAGS}" ] ; then
        LTO_MD5_FLAGS="md5deep -rel"
    fi
}

_check_for_lto_index_dir(){
    if [ -z "${LTO_INDEX_DIR}" ] ; then
        LTO_INDEX_DIR="${HOME}/Documents/lto_indexes"
    fi
}

_check_for_colons(){
    COLONALERT=$(find "${1}" -iname '*:*')
    if [ -n "${COLONALERT}" ] ; then
        _report -w "Illegal characters (colons) have been detected in the following file(s):"
        for i in ${COLONALERT} ; do
            _report -w "    ${i}"
        done
        _report -w "Exiting"
        exit 1
    fi
}

_version_schema(){
    SCHEMA_FILE="$LTO_LOGS/${TAPE_SERIAL}.schema"
    if [ -f "${SCHEMA_FILE}" ] ; then
        echo "${GREEN}Creating a new version of the ltfs schema file.${NC}"
        LASTSCHEMA="${SCHEMA_FILE%.*}_$(stat -t '%Y%m%d-%H%M%S' -l "${SCHEMA_FILE}" | awk '{print $6}').schema"
        mv -v "${SCHEMA_FILE}" "${LASTSCHEMA}"
        echo "${GREEN}$(basename ${0}): schema file is versioned - ${SCHEMA_FILE} -> ${LASTSCHEMA}.${NC}"
    fi
}

_checkdir(){
    if [[ ! -d "${1}" ]] ; then
        echo "${1}" is not a directory.
        _usage
        exit 1
    fi
}

_get_iso8601(){
    date +%FT%T
}

_get_iso8601_c(){
    date +%Y%m%d-%H%M%S
}

_unset_ffreport(){
    if [ "${FFREPORT}" ] ; then
        unset FFREPORT
    fi
}

_mkdir2(){
    local DIR2MAKE=""
    while [ "${*}" != "" ] ; do
        DIR2MAKE="${1}"
        if [ ! -d "${DIR2MAKE}" ] ; then
            mkdir -p "${DIR2MAKE}"
            if [ "${?}" -ne 0 ]; then
                _report -wt "${0}: Can't create directory at ${DIR2MAKE}"
                exit 1
            fi
        fi
        shift
    done
}

_writeerrorlog(){
    if [ ! -d "${ERRORLOGS}" ] ; then
        _mkdir2 ~/Desktop/ERRORLOGS/
        touch ~/Desktop/ERRORLOGS/error.log
    fi
    ERRORLOG=~/Desktop/ERRORLOGS/error.log
    KEY="${1}"
    VALUE="${2}"
    DATE=$(_get_iso8601_c)
    echo "${MEDIAID}, ${DATE}, ${KEY}: ${VALUE}" >> "${ERRORLOG}"
}

_maketemp(){
    mktemp -q "/tmp/$(basename "${0}").XXXXXX"
    if [ "${?}" -ne 0 ]; then
        echo "${0}: Can't create temp file, exiting..."
        _writeerrorlog "_maketemp" "was unable to create the temp file, so the script had to exit."
        exit 1
    fi
}

_log(){
    MMLOGNAME="mm.log"
    MMLOGDIR="${CUSTOM_LOG_DIR:-/tmp}"
    MMLOGFILE="${MMLOGDIR}/${MMLOGNAME}"
    if [ ! -d "${MMLOGDIR}" ] ; then
        _mkdir2 "${MMLOGDIR}"
        if [ "${?}" -ne 0 ]; then
            echo "${0}: Can't create log directory at ${MMLOGDIR}, exiting... Use mmconfig to change logging directory."
            exit 1
        fi
    fi
    OPTIND=1
    while getopts ":beacw" OPT; do
        case "${OPT}" in
            b) STATUS="start" ;;              # script is beginning
            e) STATUS="end"   ;;              # script is ending
            a) STATUS="abort" ;;              # script is aborted
            c) STATUS="comment" ;;            # comment about what script is doing
            w) STATUS="warning" ;;            # warning information
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    NOTE="${1}"
    echo $(_get_iso8601)", $(basename "${0}"), ${STATUS}, ${OP}, ${MEDIAID}, ${NOTE}" >> "${MMLOGFILE}"
}

_report(){
    local RED="$(tput setaf 1)"   # Red      - For Warnings
    local GREEN="$(tput setaf 2)" # Green    - For Declarations
    local BLUE="$(tput setaf 4)"  # Blue     - For Questions
    local NC="$(tput sgr0)"       # No Color
    local COLOR=""
    local STARTMESSAGE=""
    local ENDMESSAGE=""
    local ECHOOPT=""
    local LOG_MESSAGE=""
    OPTIND=1
    while getopts ":qdwstn" OPT; do
        case "${OPT}" in
            q) COLOR="${BLUE}" ;;                         # question mode, use color blue
            d) COLOR="${GREEN}" ;;                        # declaration mode, use color green
            w) COLOR="${RED}" ; LOG_MESSAGE="Y" ;;        # warning mode, use color red
            s) STARTMESSAGE+=([$(basename "${0}")] ) ;;   # prepend scriptname to the message
            t) STARTMESSAGE+=($(_get_iso8601) '- ' ) ;;   # prepend timestamp to the message
            n) ECHOOPT="-n" ;;                            # to avoid line breaks after echo
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    MESSAGE="${1}"
    echo "${ECHOOPT}" "${COLOR}${STARTMESSAGE[@]}${MESSAGE}${NC}"
    [ "${LOG_MESSAGE}" = "Y" ] && _log -w "${MESSAGE}"
}

_test_config(){
    for DIRECTORYVARIABLE in OUTDIR_INGESTFILE OUTDIR_INGESTXDCAM OUTDIR_PAPER AIP_STORAGE PODCASTDELIVER YOUTUBEDELIVER TMPDIR CUSTOM_LOG_DIR LTO_INDEX_DIR ; do
        if [ -d "${!DIRECTORYVARIABLE}" ] ; then
            _report -d "${DIRECTORYVARIABLE} is a valid directory"
        else
            _report -w "${DIRECTORYVARIABLE} is NOT a valid directory"
        fi
    done
}

_writeingestlog(){
    if [ -z "${INGESTLOG}" ] ; then
        echo "Error, can not write to log, ingest log not yet created"
        exit
    fi
    if [ ! -f "${INGESTLOG}" ] ; then
        _mkdir2 $(dirname "${INGESTLOG}")
        touch "${INGESTLOG}"
    fi
    KEY="${1}"
    VALUE="${2}"
    # need to add yaml style escaping
    echo "${KEY}: ${VALUE}" >> "${INGESTLOG}"
}

_readingestlog(){
    if [ -f "${INGESTLOG}" ] ; then
        KEY="${1}"
        # need to add yaml style escaping
        grep "^${1}:" "${INGESTLOG}" | tail -n1 | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
    fi
}

_run(){
    RUN_ERR=""
    _report -sdt "Running: ${*}"
    if [[ ! "${DRYRUN}" == true ]] ; then
        "${@}"
    fi
    RUN_ERR="${?}"
    if [[ "${RUN_ERR}" != 0 ]] ; then
        _report -wts "Error: Running: \"${*}\" gave an Error Code - ${RUN_ERR}"
        _writeerrorlog "_run" "Running: \"${*}\" gave an Error Code - ${RUN_ERR}"
    fi
}

_run_critical(){
    _run "${@}"
    if [[ "${RUN_ERR}" != 0 ]] ; then
        _report -wts "The process ran into a critical error and can not proceed."
        exit 1
    fi
}

_run_critical_event(){
    _run "${@}"
        _eventoutcome_update
    if [[ "${RUN_ERR}" != 0 ]] ; then
        _report -wts "The process ran into a critical error and can not proceed."
        exit 1
    fi
}

_black_at_ends(){
    INPUT_MOVIE="${1}"
    ANALYSIS_HEAD_SECONDS=10
    ANALYSIS_TAIL_SECONDS=-10
    _report -dt "Analyzing $(basename "${INPUT_MOVIE}") for excessive black at head or tail."
    HEAD_BLACK=$(ffmpeg -t "${ANALYSIS_HEAD_SECONDS}" -i "${1}" -an -filter_complex     blackdetect=pix_th=0.05 -loglevel debug -f null - 2>&1 | grep -c -o picture_black_ratio:1)
    _report -dt "Black frames in first ${ANALYSIS_HEAD_SECONDS} seconds: ${HEAD_BLACK}."
    TAIL_BLACK=$(ffmpeg -sseof "${ANALYSIS_TAIL_SECONDS}" -i "${1}" -an -filter_complex     blackdetect=pix_th=0.05 -loglevel debug -f null - 2>&1 | grep -c -o picture_black_ratio:1)
    _report -dt "Black frames in last  ${ANALYSIS_HEAD_SECONDS} seconds: ${TAIL_BLACK}."
}

_get_frame_count(){
    INPUT_MOVIE="${1}"
    CONTAINERFRAMECOUNT=$(mediainfo --inform="Video;%FrameCount%" "${INPUT_MOVIE}")
    VIDEOTRACKFRAMECOUNT=$(mediainfo --inform="Video;%Source_FrameCount%" "${INPUT_MOVIE}")
    if [ ! -z "${VIDEOTRACKFRAMECOUNT}" ] ; then
        if [ "${VIDEOTRACKFRAMECOUNT}" -ne "${CONTAINERFRAMECOUNT}" ] ; then
            _report -dt "The frame count according to the container is: ${CONTAINERFRAMECOUNT}"
            _report -dt "The frame count according to the video track is: ${VIDEOTRACKFRAMECOUNT}"
            _report -wt "warning - there are discrepancies between the container frame count and video track frame count. This could result in the desynchronization of audio and video."
            echo "Enter q to quit, any other key to continue: "
            read A2
            [[ "${A2}" = "q" ]] && exit 0
        fi
    fi
}

_ask_operator(){
    if [ -z "${OP}" ] ; then
        _report -qn "Enter the name of the operator or 'q' to quit: "
        read -e OP
        [ -z "${OP}" ] && _ask_operator
        [[ "${OP}" = "q" ]] && exit 0
    fi
}

_ask_mediaid(){
    if [ -z "${MEDIAID}" ] ; then
        _report -qn "Enter a unique MEDIA ID: "
        read -e MEDIAID
        [ -z "${MEDIAID}" ] && _ask_mediaid
        # option to quit
        [[ "${MEDIAID}" = "q" ]] && exit 0
        # validate id and perhaps fail with exit
        [ -z "${MEDIAID}" ] && { _report -wt "ERROR You must enter a valid MEDIA ID" ; exit ;};
        [ ! -z $(echo "${MEDIAID}" | grep -v "^[A-Z0-9_-]*$") ] && { _report -wt "ERROR The MEDIA ID must only contain capital letters, numbers, hyphen and underscore" ; exit 1 ;};
    fi
}

_ask_input(){
    if [ -z "${INPUT}" ] ; then
        _report -qn "Drag in the file: "
        read -e INPUT
        [ -z "${INPUT}" ] && _ask_input
        [[ "${INPUT}" = "q" ]] && exit 0
        basename=$(basename "${INPUT}")
    fi
}

_ask_intime(){
    # TIME_REGEX tests for either S.mmm or HH:MM:SS.mmm time formats where HH is two digit hour, MM is two digit minute, S is number of seconds, SS is two digit seconds, and .mmm is milliseconds from between 0 and 3 decimals
    TIME_REGEX="^\([0-9]\+\(\.[0-9]\{1,3\}\)\?\|[0-9]\{2\}:[0-5][0-9]:[0-5][0-9]\(\.[0-9]\{1,3\}\)\?\)$"
    while [[ ! $(echo "${INTIME}" | grep "${TIME_REGEX}") ]] ; do
        _report -q "Enter point of time to start transcoding."
        _report -q "Enter no value if no intime for transcoding is needed. Transcoding will then start from the beginning."
        _report -q "Must be in HH:MM:SS.mmm or S.mmm format. Note mmm is milliseconds and not frames."
        _report -qn "INTIME: "
        read INTIME
        if [[ "${INTIME}" = "" ]] ; then
            break
        elif [[ ! $(echo "${INTIME}" | grep "${TIME_REGEX}") ]] ; then
            _report -w "In time must be in seconds or in HH:MM:SS.mmm format."
        fi
    done
}

_ask_outtime(){
    # TIME_REGEX tests for either S.mmm or HH:MM:SS.mmm time formats where HH is two digit hour, MM is two digit minute, S is number of seconds, SS is two digit seconds, and .mmm is milliseconds from between 0 and 3 decimals
    TIME_REGEX="^\([0-9]\+\(\.[0-9]\{1,3\}\)\?\|[0-9]\{2\}:[0-5][0-9]:[0-5][0-9]\(\.[0-9]\{1,3\}\)\?\)$"
    while [[ ! $(echo "${OUTTIME}" | grep "${TIME_REGEX}") ]] ; do
        _report -q "Enter point of time to stop transcoding."
        _report -q "Enter no value if no outtime for transcoding is needed. Transcoding will proceed to the end."
        _report -q "Must be in HH:MM:SS.mmm or S.mmm format. Note mmm is milliseconds and not frames."
        _report -qn "OUTTIME: "
        read OUTTIME
        if [[ "${OUTTIME}" = "" ]] ; then
            break
        elif [[ ! $(echo "${OUTTIME}" | grep "${TIME_REGEX}") ]] ; then
            _report -w "Out time must be in seconds or in HH:MM:SS.mmm format."
        fi
    done
}

_ask_photos(){
    MEDIAID="${1}"
    echo ""

    _after_capture_process(){
        PHOTOLOC="$(grep -a "^Saving file as" "${GPHOTO2LOG}" | sed 's/Saving file as //g')"
        while [[ ! -f "$PHOTOLOC" ]] ; do
            sleep 1
            PHOTOLOC="$(grep -a "^Saving file as" "${GPHOTO2LOG}" | sed 's/Saving file as //g')"
        done
        _report -d "Captured ${PHOTOLOC}, opening..."
        open "${PHOTOLOC}"
        echo "" > "${GPHOTO2LOG}"
        _report -q -n "Hit 'd' to discard $(basename ${PHOTOLOC}) or enter to continue: "
        read answer
        if [[ "${answer}" = "d" ]] ; then
            rm -v "${PHOTOLOC}"
        fi
    }

    _stop_ptpcamera(){
        PID=$(ps ux | grep PTPCamera | grep -v grep | awk '{print $2}' | xargs)
        if [[ -n "$PID" ]] ; then
            _report -d "closing PTPCamera ($PID)"
            killall PTPCamera
        fi
    }

    _stop_gphoto(){
        if [[ -n "${GPHOTO2_PID}" ]] ; then
            if [[ $(ps -e | awk '{print $1}' | grep "^${GPHOTO2_PID}$") ]] ; then
                _report -d "Shutting down gphoto2 (${GPHOTO2_PID})"
                kill -9 "${GPHOTO2_PID}"
            fi
        fi
    }

    _stop_ptpcamera
    trap _stop_gphoto SIGHUP SIGINT SIGTERM
    MEDIAID="${1}"
    _report -q -n "Hit enter to take a photograph ['q' to quit, 'f' when finished with photos, 's' or 'S' to skip this step]: "
    read answer
    if [[ "${answer}" = "q" ]] ; then
        exit
    elif [[ "${answer}" != [fsS] ]] ; then
        gphoto2 --summary >/dev/null
        GPHOTO_ERR="$?"
        while [[ "${GPHOTO_ERR}" != "0" ]] ; do
            echo -n "Camera appears to not be connected. Hit 'q' to quit, 'r' to retry, 's' or 'S' to skip this step: "
            read answer
            if [[ "${answer}" = "q" ]] ; then
                _stop_gphoto
                exit
            elif [[ "${answer}" = "r" ]] ; then
                _ask_photos "${MEDIAID}"
            else
                NEVERMIND=1
                _report -d "Skipping capture process"
                break
            fi
            gphoto2 --summary >/dev/null
            GPHOTO_ERR="$?"
        done
        if [[ ! "$NEVERMIND" ]] ; then
            GPHOTO2LOG=$(_maketemp)
            _stop_ptpcamera
            OBJ_PHOTO_DIR="${OUTDIR_INGESTFILE}/${MEDIAID}/metadata/depictions/object_photos"
            _mkdir2 "${OBJ_PHOTO_DIR}"
            gphoto2 --capture-image-and-download -I -1 --filename "${OBJ_PHOTO_DIR}/${MEDIAID}_photo_%03n.%C" > "${GPHOTO2LOG}" &
            GPHOTO2_PID="${!}"
            _after_capture_process
            answer="x"
            if [[ -n "${GPHOTO2_PID}" ]] ; then
                _stop_ptpcamera
                while [[ "${answer}" != "q" && "${answer}" != "f" ]] ; do
                    _report -q -n "Hit enter to take another photograph ['q' to quit, 'f' when finished with photos]: "
                    read answer
                    if [[ "${answer}" = "q" ]] ; then
                        _stop_gphoto
                        exit
                    elif [[ "${answer}" = "f" ]] ; then
                        _stop_gphoto
                        break
                    else
                        kill -SIGUSR1 "${GPHOTO2_PID}"
                        _after_capture_process
                    fi
                done
            else
                _report -wt "Error: gphoto2 is not running."
            fi
        fi
        _stop_gphoto
    fi
}

_check_dependencies(){
    DEPS_OK=YES
    while [ "${*}" != "" ] ; do
        DEPENDENCY="${1}"
        if [ ! $(which "${DEPENDENCY}") ] ; then
            _report -wt "This script requires ${DEPENDENCY} to run but it is not installed"
            _report -wt "If you are running ubuntu or debian you might be able to install ${DEPENDENCY} with the following command"
            _report -wt "sudo apt-get install ${DEPENDENCY}"
            _report -wt "If you are running mac you might be able to install ${DEPENDENCY} with the following command"
            _report -wt "brew install ${DEPENDENCY}"
            DEPS_OK=NO
        fi
        shift
    done
    if [[ "${DEPS_OK}" = "NO" ]]; then
        _report -wt "Unmet dependencies"
        _report -wt "Aborting!"
        exit 1
    else
        return 0
    fi
}

_initialize_make(){
    DELIVERDIR=""
    DRYRUN=false
    EMAILADDRESS=""
    OUTPUTDIR_FORCED=""
    _cleanup(){
        _log -a "Process aborted"
        echo
        _report -wts "THE PROCESS WAS ABORTED"
        exit 1
    }
    trap _cleanup SIGHUP SIGINT SIGTERM
}

_check_deliverdir(){
    if [ ! -d "${DELIVERDIR}" ] ; then
        _report -wt "The delivery directory, ${DELIVERDIR}, does not exist. Can not deliver the OUTPUT of $(basename "${0}")(${OUTPUT_TYPE})."
        _writeerrorlog "_checkdeliverdir" "The specified delivery directory does not exist, and the output could not be delivered."
    fi
}

_check_outputdir_forced(){
    if [ ! -d "${OUTPUTDIR_FORCED}" ] ; then
        _report -wt "The directory, ${OUTPUTDIR_FORCED}, does not exist. Can not write the output of $(basename "${0}")."
        _writeerrorlog "_check_outputdir_forced" "The specified directory does not exist, and the output could not be delivered."
    fi
}

_check_emailaddress(){
    EMAILREGEX="^((\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)*([,])*)*$"
    if ! $(echo "${1}" | grep -Eq "^((\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*)*([,])*)*$") ; then
        _report -wt "${1} is not a valid email address."
        _writeerrorlog "_check_emailaddress" "The email address provided was not a valid email address."
    fi
}

_get_prettyduration(){
    PRETTYDURATION=$(ffprobe "${1}" -show_format -pretty 2>/dev/null | grep "^duration=" | cut -d= -f2)
}

_get_duration(){
    DURATION=$(ffprobe "${1}" -show_format 2>/dev/null | grep "^duration=" | cut -d = -f 2)
}

_get_broadcastduration(){
    BROADCASTDURATION=$(mediainfo --inform="General;%Duration_String4%" "${1}")
}

_get_seconds(){
    FILESECONDS=$(ffprobe "${1}" -show_format 2>/dev/null | grep "^duration=" | cut -d= -f2)
}

_get_chapterlist(){
    CHAPTER_LIST="$(ffprobe -v 0 "${1}" -show_entries chapter=id,start_time,end_time:chapter_tags=title -of compact=p=0:nk=1)"
}

_email_delivery(){
    EMAILTO="${1}"
    if [ "${EMAILTO}" ] ; then
        _get_prettyduration "${OUTPUT}"
        temp_message=$(_maketemp)
        if [[ -f "${INGESTLOG}" ]] ; then
            FROMLOG="Operator: $(_readingestlog "operator")\n
Processing Computer: $(_readingestlog "computer_name")
Audio True Peak (dBTP): $(_readingestlog "measured_true_peak")
Integrated Loudness (LUFS): $(_readingestlog "r128_integrated_loudness")
Loudness Adjustment (LUFS): $(_readingestlog "loudness_adjustment")
Loudness Range (LU): $(_readingestlog "r128_loudness_range")
Threshold (LUFS) : $(_readingestlog "measured_threshold")
Out of Phase Audio Ranges: $(_readingestlog "Out_of_phase_audio_ranges")"
        fi
        echo -e "Subject: [delivery] $(basename "${OUTPUT}")\n
A file has been delivered to ${DELIVERDIR}.\n
Process: $(basename "${0}")
MediaID: ${MEDIAID}\n
Filename: ${OUTPUT}
Sourcefile: ${SOURCEFILE}
Duration: ${PRETTYDURATION}\n
Decoding_options: ${INPUTOPTIONS[@]}
Encoding_options: ${MIDDLEOPTIONS[@]}\n
Delivery Exit Status: ${DELIVER_EXIT_STATUS}\n
${FROMLOG}
\n
Enjoy!\n\n" > "$temp_message"
        waveform_image="${OUTDIR_INGESTFILE}/${MEDIAID}/metadata/depictions/${MEDIAID}_waveform.png"
        if [ -f "${waveform_image}" ] ; then
            _report -d "Adding a waveform to the email from ${waveform_image}"
            # email solution borrowed from http://stackoverflow.com/a/8063489
            # --- generated values ---
            BOUNDARY="unique-boundary-$RANDOM"
            BODY_MIMETYPE=$(file -Ib "$temp_message" | cut -d";" -f1)   # detect mime type
            ATT_MIMETYPE=$(file -Ib "${waveform_image}" | cut -d";" -f1)     # detect mime type
            ATT_ENCODED=$(base64 < "${waveform_image}")  # encode attachment
            # --- generate MIME message and pipe to sendmail ---
            cat <<EOF | sendmail -f "${EMAIL_FROM}" -F "${EMAILTO}" "${EMAILTO}"
MIME-Version: 1.0
From: "${EMAIL_FROM}"
To: "${EMAILTO}"
Subject: [delivery] $(basename "${OUTPUT}")
Content-Type: multipart/mixed; boundary="$BOUNDARY"

--$BOUNDARY
Content-Type: $BODY_MIMETYPE
Content-Disposition: inline

$(cat "$temp_message")
--$BOUNDARY
Content-Type: $ATT_MIMETYPE; name="$(basename "${waveform_image}")"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="$(basename "${waveform_image}")"

$ATT_ENCODED
--$BOUNDARY
EOF
        else
            sendmail -f "${EMAIL_FROM}" -F "${EMAILTO}" "${EMAILTO}" < "$temp_message"
        fi
        if [ -f "$temp_message" ] ; then
            rm "$temp_message"
        fi
    fi
}

_deliver_output(){
    # argument 1 if used should be the email to report delivery to
    EMAILTO="${1}"
    if [ "${DELIVERDIR}" ] ; then
        echo DELIVERING OUTPUT ACTIVITED with "${DELIVERDIR}"
        _report -dt "Delivering ${OUTPUT} to ${DELIVERDIR}"
        _run cp -av "${OUTPUT}" "${DELIVERDIR}/"
        DELIVER_EXIT_STATUS="${?}"
        _email_delivery "${EMAILTO}"
    fi
}

_ask(){
    # This function requires 2 arguments
    # 1) A prompt
    # 2) The label for the metadata value
    read -e -p "${1}" RESPONSE
    if [ -z "${RESPONSE}" ] ; then
        _ask "${1}" "${2}"
    else
        LOG+="${2}: ${RESPONSE}\n"
    fi
    echo
}

_offerChoice(){
    # This function requires 3 arguments
    # 1) A prompt
    # 2) The label for the metadata value
    # 3) A vocabulary list
    PS3="${1}"
    LABEL="${2}"
    eval set "${3}"
    select OPTION in "${@}" ; do
        break
    done
    LOG+="${LABEL}: ${OPTION}\n"
    echo
}

_make_mezz_for_xdcam(){
    SOM="${1}"
    DUR="${2}"

    TMC_MS=$(mediainfo --inform="Video;%Delay%" "${3}")
    TMC_SMP=$(mediainfo --inform="Video;%Delay/String3%" "${3}")
    TMC_SEC=$(echo "${TMC_MS} * 0.001" | bc)

    SOM_H=$(echo "${SOM}" | cut -c 1-2)
    SOM_M=$(echo "${SOM}" | cut -c 4-5)
    SOM_S=$(echo "${SOM}" | cut -c 7-8)
    SOM_F=$(echo "${SOM}" | cut -c 10-11)
    SOM_FC=$(echo "scale=3; (((((3600 * ${SOM_H})+(60 * ${SOM_M})+ ${SOM_S} ) * 30)+ ${SOM_F} ) - ( 2 * (((60 * ${SOM_H})+ ${SOM_M} ) - (((60 * ${SOM_H})+ ${SOM_M} ) / 10 )))) / 29.97" | bc)

    DUR_H=$(echo "${DUR}" | cut -c 1-2)
    DUR_M=$(echo "${DUR}" | cut -c 4-5)
    DUR_S=$(echo "${DUR}" | cut -c 7-8)
    DUR_F=$(echo "${DUR}" | cut -c 10-11)
    DUR_FC=$(echo "scale=3; (((((3600 * ${DUR_H})+(60 * ${DUR_M})+ ${DUR_S} ) * 30)+ ${DUR_F} ) - ( 2 * (((60 * ${DUR_H})+ ${DUR_M} ) - (((60 * $DUR_H)+ $DUR_M ) / 10 )))) / 29.97" | bc)

    REL_START=$(echo "scale=3; ${SOM_FC} - ${TMC_SEC}" | bc)
    pushd $(dirname "${4}")
    _report -dt "Starting ffmpeg to trim mxf file at $(date) This will take a few minutes..."
    ffmpeg 2</dev/null -report -y -ss "${REL_START}" -t "${DUR_FC}" -i "${3}" -map 0:v -map 0:a:0 -map 0:a:1 -c copy "${4}"
    popd
}

_add_video_filter(){
    OPTIND=1
    unset ADDASPREFIX
    while getopts ":p" OPT ; do
        case "${OPT}" in
            p) ADDASPREFIX=true ;;
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    local FILTER2ADD="${1}"
    if [[ -n "${FILTER2ADD}" ]] ; then
        if [[ -n "${next_video_filter_prefix}" ]] ; then
            FILTER2ADD="${next_video_filter_prefix}${FILTER2ADD}"
            unset next_video_filter_prefix
        fi
        if [[ -z "${VIDEOFILTERCHAIN}" ]] ; then
            VIDEOFILTERCHAIN="${FILTER2ADD}"
        elif [[ "${ADDASPREFIX}" = true ]] ; then
            if [[ "${FILTER2ADD: -1}" = ";" || "${FILTER2ADD: -1}" = "," ]] ; then
                VIDEOFILTERCHAIN="${FILTER2ADD}${VIDEOFILTERCHAIN}"
            else
                VIDEOFILTERCHAIN="${FILTER2ADD},${VIDEOFILTERCHAIN}"
            fi
        else
            if [[ "${VIDEOFILTERCHAIN: -1}" = ";" || "${VIDEOFILTERCHAIN: -1}" = "," ]] ; then
                VIDEOFILTERCHAIN="${VIDEOFILTERCHAIN}${FILTER2ADD}"
            else
                VIDEOFILTERCHAIN="${VIDEOFILTERCHAIN},${FILTER2ADD}"
            fi
        fi
    fi
}

_add_audio_filter(){
    OPTIND=1
    unset ADDASPREFIX
    while getopts ":p" OPT ; do
        case "${OPT}" in
            p) ADDASPREFIX=true ;;
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    local FILTER2ADD="${1}"
    if [[ -n "${FILTER2ADD}" ]] ; then
        if [[ -n "${next_audio_filter_prefix}" ]] ; then
            FILTER2ADD="${next_audio_filter_prefix}${FILTER2ADD}"
            unset next_audio_filter_prefix
        fi
        if [[ -z "${AUDIOFILTERCHAIN}" ]] ; then
            AUDIOFILTERCHAIN="${FILTER2ADD}"
        elif [[ "${ADDASPREFIX}" = true ]] ; then
            if [[ "${FILTER2ADD: -1}" = ";" || "${FILTER2ADD: -1}" = "," ]] ; then
                AUDIOFILTERCHAIN="${FILTER2ADD}${AUDIOFILTERCHAIN}"
            else
                AUDIOFILTERCHAIN="${FILTER2ADD},${AUDIOFILTERCHAIN}"
            fi
        else
            if [[ "${AUDIOFILTERCHAIN: -1}" = ";" || "${AUDIOFILTERCHAIN: -1}" = "," ]] ; then
                AUDIOFILTERCHAIN="${AUDIOFILTERCHAIN}${FILTER2ADD}"
            else
                AUDIOFILTERCHAIN="${AUDIOFILTERCHAIN},${FILTER2ADD}"
            fi
        fi
    fi
}

_find_input (){
    CONCATSOURCE=""
    SOURCEFILE=""
    ISOBJECT=""
    INFOOVERLAY=""
    unset FFMPEGINPUT
    if [ -f "${1}" ] ; then
        # if the input is a file then just `-i file`
        ISOBJECT="Y"
        SOURCEFILE="${1}"
        FFMPEGINPUT+=(-i)
        FFMPEGINPUT+=("${SOURCEFILE}")
    elif [ -d "${1}/objects" ] ; then
        EXPECTEDSERVICEFILE="${1}/objects/service/$(basename "${1}").mov"
        if [[ -s "${EXPECTEDSERVICEFILE}" && "${PREFERRED_SOURCE}" == "service" ]] ; then
            ISOBJECT="N"
            SOURCEFILE="${EXPECTEDSERVICEFILE}"
            FFMPEGINPUT+=(-i)
            FFMPEGINPUT+=("${SOURCEFILE}")
        else
            if [[ "${PREFERRED_SOURCE}" == "service" ]] ; then
                _report -wt "This process normally uses the service file as a source but it is missing from this package, so will try to use the objects file(s)."
            fi
            ISOBJECT="Y"
            INPUTFILES=$(_maketemp)
            if [[ -d "${1}/objects/restoration" ]] ; then
                 LOOKHERE="${1}/objects/restoration"
                 _report -dt "This package contains a restoration, using that for processing."
            else
                 LOOKHERE="${1}/objects"
            fi
            # find av files in a directory and output to a temp list
            find "${LOOKHERE}" -type f -size +0 "${OBJECTS_FIND_EXCLUSIONS[@]}" | sort | while read file ; do
                streamcount=$(ffprobe -loglevel quiet "$file" -show_entries format=nb_streams -of default=nw=1:nk=1)
                duration_ts=$(ffprobe -loglevel quiet "$file" -show_entries stream=duration_ts -of default=nw=1:nk=1)
	
		# Cast empty value into 0 integer
		if [ -z "$streamcount" ]; then
		    streamcount=0
		fi
		if [ -z "$duration_ts" ]; then
		    duration_ts=0
		fi
		
                if [[ "$streamcount" > 0  && "${duration_ts}" != 1 ]] ; then
                    _report -d "Input file: $file"
                    echo "$file" >> "${INPUTFILES}"
                fi
            done
            INPUTFILECOUNT=$(wc -l "${INPUTFILES}" | awk '{print $1}')
            if [[ "${INPUTFILECOUNT}" = 0 ]] ; then
                _report -w "Error no audiovisual input files were found."
                _writeerrorlog "_find_input" "A valid source audiovisual file was not found, so the script could not proceed."
                exit 1
            elif [[ "${INPUTFILECOUNT}" = 1 ]] ; then
                SOURCEFILE=$(cat "${INPUTFILES}" | head -n 1)
                FFMPEGINPUT+=(-i)
                FFMPEGINPUT+=("${SOURCEFILE}")
            else
                VOLADJUST="N"
                INPUTOPTIONS+=(-f concat)
                INPUTOPTIONS+=(-safe 0)
                FFCONCATFILE="$(_maketemp).ffconcat"
                FFMETADATAFILE="$(_maketemp).ffmetadata"
                echo "$FFCONCATFILE $FFMETADATAFILE"
                CHAPTER_TALLY=0
                echo ";FFMETADATA1" > "${FFMETADATAFILE}"
                echo >> "${FFMETADATAFILE}"
                while read i ; do
                    duration4cat=$(ffprobe -loglevel quiet "${i}" -show_entries format=duration -of default=nw=1:nk=1)
                    _get_timecode "${i}"
                    if [[ "${TIMECODE}" ]] ; then
                        TIMECODEESACPE=$(echo "${TIMECODE}" | sed 's|:|\\:|g')
                        INFOOVERLAY+="drawtext=fontfile=/System/Library/Fonts/Monaco.dfont:timecode='${TIMECODEESACPE}':r=30000/1001:fontcolor=white@0.4:fontsize=32:shadowx=1:shadowy=1:box=1:boxcolor=DarkGray@0.2:x=32:y=h-32:enable=between(t\,${CHAPTER_TALLY}\,${CHAPTER_TALLY}+${duration4cat}),"
                    fi
                    if [[ "${INPUTFILECOUNT}" -gt 1 ]] ; then
                        INFOOVERLAY+="drawtext=fontfile=/System/Library/Fonts/Monaco.dfont:text='    ${i#*objects/}':fontcolor=white@0.4:fontsize=32:shadowx=1:shadowy=1:box=1:boxcolor=DarkGray@0.2:x=32+224:y=h-32:enable=between(t\,${CHAPTER_TALLY}\,${CHAPTER_TALLY}+${duration4cat}),"
                    fi

                    # write to ffconcat
                    printf "file " >> "${FFCONCATFILE}"
                    printf '%q' "${i}" >> "${FFCONCATFILE}"
                    echo >> "${FFCONCATFILE}"
                    echo "duration $duration4cat" >> "${FFCONCATFILE}"

                    # write to ffmetadata for chapters and data to subtitle file
                    echo "[CHAPTER]" >> "${FFMETADATAFILE}"
                    echo "TIMEBASE=1/100000" >> "${FFMETADATAFILE}"
                    echo "START=$(echo "${CHAPTER_TALLY}*100000" | bc)" >> "${FFMETADATAFILE}"
                    CHAPTER_TALLY="$(echo "scale=6; ${CHAPTER_TALLY}+${duration4cat}" | bc -l)"
                    echo "END=$(echo "${CHAPTER_TALLY}*100000" | bc)" >> "${FFMETADATAFILE}"
                    echo "title=${i#*objects/}" >> "${FFMETADATAFILE}"
                done < "${INPUTFILES}"
                SOURCEFILE=$(cat "${INPUTFILES}" | head -n 1)
                FFMPEGINPUT+=(-i)
                FFMPEGINPUT+=("${FFCONCATFILE}")
                FFMPEGINPUT+=(-i)
                FFMPEGINPUT+=("${FFMETADATAFILE}")
                FFMPEGINPUT+=(-map_metadata 1)
            fi
        fi
    else
        _report -wt "A valid source file isn't found in ${LOOKHERE}."
        _writeerrorlog "_find_input" "A valid source file was not found, so the script could not proceed."
        exit 1
    fi
    LOG+="SOURCEFILE: ${SOURCEFILE}\n"
    # handle exceptions for certain types of source files
    if [[ "${SOURCEFILE#*.}" = "iso" ]] ; then
        _report -dt "Detecting iso input and hoping its a dvd image."
        if [[ "$(uname -s)" = "Darwin" ]] ; then
            MOUNTPATH="$(hdiutil mount "${SOURCEFILE}" | awk '{print $2}')"
            _report -dt "Mounting iso at ${MOUNTPATH}"
        else
            MOUNTPATH="/tmp/temporary_dvd_path"
            rm -rfv "${MOUNTPATH}"
            if [ ! -d "${MOUNTPATH}" ] ; then
                mkdir -p "${MOUNTPATH}"
            fi
            7z e -r -o"${MOUNTPATH}" "${SOURCEFILE}"
        fi
        OLDSOURCEFILE="${SOURCEFILE}"
        FFMPEGINPUT=(-i)
        FFMPEGINPUT+=("concat:$(find "${MOUNTPATH}" -iname "VTS*[1-9].VOB" | sort | sed -e :a -e '$!N;s/\n/|/;ta')")
        SOURCEFILE=$(find "${MOUNTPATH}" -iname "VTS_*_1.VOB" | head -1)
        _report -dt "Using ${CONCATSOURCE} for transcoding."
        _report -dt "Using ${SOURCEFILE} for assessment."
        _report -wt "Extracting to ${MOUNTPATH}. Please unmount ${MOUNTPATH} later."
    elif [[ "${SOURCEFILE#*.}" = "mkv" || "${SOURCEFILE#*.}" = "mka" ]] ; then
        # if the source file is an mkv or mka, then check if it has a Presentation Chapter Edition
        if [[ -n $(mkvextract tags "${SOURCEFILE}" | xmlstarlet sel -t -m "/Tags/Tag/Simple[String='Presentation']" -v String) ]] ; then
            _report -dt "The input file ($(basename "${SOURCEFILE}")) contains a Chapter Edition called 'Presentation', will use that for transcoding."
            LISTCHAPTERS=$(mkvextract chapters "${SOURCEFILE}" | xmlstarlet sel -t -m Chapters/EditionEntry[EditionFlagDefault='1']/ChapterAtom -v ChapterTimeStart -o "-" -v ChapterTimeEnd -o "-" -v ChapterSegmentUID -n -)
            SegmentUIDs=$(mkvextract chapters "${SOURCEFILE}" | xmlstarlet sel -t -m Chapters/EditionEntry[EditionFlagDefault='1']/ChapterAtom/ChapterSegmentUID -v . -n | sort -u)
            if [[ -n "${LISTCHAPTERS}" ]]; then
              _report -d "Found this chapter list:"
              _report -d "${LISTCHAPTERS}"
              unset FFMPEGINPUT
              INPUTOPTIONS+=(-f concat)
              INPUTOPTIONS+=(-safe 0)
              FFCONCATFILE=$(_maketemp)
              while read chapter ; do
                STARTTIME=$(echo "${chapter}" | cut -d- -f1)
                ENDTIME=$(echo "${chapter}" | cut -d- -f2)
                CHAPSEGMENTUID=$(echo "${chapter}" | cut -d- -f3)
                if [[ -n "${CHAPSEGMENTUID}" ]]; then
                  MKVFOLDER=$(dirname "${SOURCEFILE}")
                  while read file ; do
                    FILESEGMENTUID=$(mkvinfo "${file}" | grep "Segment UID:" | cut -d : -f2 | sed 's/0x//g;s/ //g')
                    unset MATCHMKV
                    if [[ "${CHAPSEGMENTUID}" == "${FILESEGMENTUID}" ]] ; then
                      MATCHMKV="${file}"
                      break 1
                    fi
                  done < <(find "${MKVFOLDER}" -type f \( -name "*.mkv" -o -name "*.mka" \))
                  if [[ -n "${MATCHMKV}" ]]; then
                    INPUTFILE="$MATCHMKV"
                  else
                    echo "Error: did not find a file to match ${CHAPSEGMENTUID}"
                    exit
                  fi
                else
                  INPUTFILE="${SOURCEFILE}"
                fi
                printf "file " >> "${FFCONCATFILE}"
                printf '%q' "${INPUTFILE}" >> "${FFCONCATFILE}"
                echo >> "${FFCONCATFILE}"
                echo "inpoint ${STARTTIME}" >> "${FFCONCATFILE}"
                echo "outpoint ${ENDTIME}" >> "${FFCONCATFILE}"
              done < <(echo "${LISTCHAPTERS}")
              FFMPEGINPUT+=(-i)
              FFMPEGINPUT+=("${FFCONCATFILE}")
            fi
        fi
    fi
}

_get_width(){
    WIDTH=$(ffprobe "${1}" -show_streams -select_streams v:0 2>/dev/null | grep "^width=" | cut -d = -f 2)
}

_get_height(){
    HEIGHT=$(ffprobe "${1}" -show_streams -select_streams v:0 2>/dev/null | grep "^height=" | cut -d = -f 2)
}

_get_dar(){
    DAR=$(ffprobe "${1}" -show_streams -select_streams v:0 2>/dev/null | grep "^display_aspect_ratio=" | cut -d = -f 2 | sed 's|:|/|g')
    if [[ "${DAR}" = "0/1" || "${DAR}" = "N/A" ]] ; then
        _get_width "${1}"
        _get_height "${1}"
        DAR="${WIDTH}/${HEIGHT}"
    fi
}

_get_sar(){
    SAR=$(ffprobe "${1}" -show_streams -select_streams v:0 2>/dev/null | grep "^sample_aspect_ratio=" | cut -d = -f 2 | sed 's|:|/|g')
    if [[ "${SAR}" = "0/1" || "${SAR}" = "N/A" ]] ; then
        SAR="1/1"
    fi
}

_has_first_two_tracks_mono(){
    AUDIO_TRACK_COUNT="$(ffprobe 2>/dev/null "${1}" -show_streams | grep -c "codec_type=audio")"
    [ "${AUDIO_TRACK_COUNT}" -ge 2 ] && \
    [ $(ffprobe 2>/dev/null "${1}" -show_streams -select_streams a:0 | grep "^channels=" | cut -d= -f2) = "1" ] && \
    [ $(ffprobe 2>/dev/null "${1}" -show_streams -select_streams a:1 | grep "^channels=" | cut -d= -f2) = "1" ] && \
    MULTIMONO=true
    [ "${AUDIO_TRACK_COUNT}" -ge 2 ] && \
    [ $(ffprobe 2>/dev/null "${1}" -show_streams -select_streams a:0 | grep "^channels=" | cut -d= -f2) = "1" ] && \
    FIRSTMONO=true
}

_get_audio_index(){
    # get ffmpeg's index value of the first audio stream. Useful for do custom channel mappings.
    AUDIO_INDEX_1=$(ffprobe "${1}" -show_streams -select_streams a:0 2>/dev/null | grep "^index=" | cut -d = -f 2)
    AUDIO_INDEX_2=$(ffprobe "${1}" -show_streams -select_streams a:1 2>/dev/null | grep "^index=" | cut -d = -f 2)
}

_get_audio_channels(){
    # get ffmpeg's channel count of the first audio stream.
    AUDIO_CHANNELS=$(ffprobe "${1}" -show_streams -select_streams a 2>/dev/null | grep "^channels=" | cut -d = -f 2 | head -n 1)
}

_get_channel_layout(){
    # get ffmpeg's channel count of the first audio stream.
    CHANNEL_LAYOUT=$(ffprobe "${1}" -show_streams -select_streams a 2>/dev/null | grep "^channel_layout=" | cut -d = -f 2 | head -n 1)
}

_get_audio_mapping(){
    OPTIND=1
    unset PBSMIX
    ADD_VOLADJ="N"
    while getopts ":bvlr" OPT ; do
        case "${OPT}" in
            b) PBSMIX="Y" ;;
            v) ADD_VOLADJ="Y" ;;
            l) AUDIOMAP="L" ;;
            r) AUDIOMAP="R" ;;
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    _get_audio_index "${1}"
    _get_audio_channels "${1}"
    _get_channel_layout "${1}"
    _has_first_two_tracks_mono "${1}"
    if [[ ( "${AUDIOMAP}" = "L" || "${AUDIOMAP}" = "R" ) && "${FIRSTMONO}" = true ]] ; then
        _report -wt "Channel mapping was requested, but first track is mono. Request ignored."
    fi
    if [[ "${AUDIOMAP}" = "M" ]] ; then
        _report -wt "Only use the first track."
        _add_audio_filter -p "channelmap=0:mono"
        _add_audio_filter "aformat=channel_layouts=stereo" 
    elif [[ "${AUDIOMAP}" = "L" && "${FIRSTMONO}" != true ]] ; then
        _report -wt "Use of left-channel only was requested."
        _add_audio_filter -p "channelmap=0:mono"
        _add_audio_filter "aformat=channel_layouts=stereo"
    elif [[ "${AUDIOMAP}" = "R" && "${FIRSTMONO}" != true ]] ; then
        _report -wt "Use of right-channel only was requested."
        _add_audio_filter -p "channelmap=1:mono"
        _add_audio_filter "aformat=channel_layouts=stereo"
    elif [[ "${AUDIOMAP}" = "D" && "${FIRSTMONO}" = true ]] ; then
        _report -wt "Downmix first two mono tracks"
        _add_audio_filter "[0:a:0][0:a:1]amerge,pan=stereo|c0=0.5*c0+0.5*c1|c1=0.5*c0+0.5*c1"
    elif [[ "${AUDIOMAP}" = "A" ]] ; then
        unset AMERGE_LIST
        C=0
        while "$C" -lte "${AUDIO_TRACK_COUNT}" ; do
            AMERGE_LIST+="[0:a:$i]"
            ((C++))
        done
        _report -wt "Will mix together ${AUDIO_TRACK_COUNT} tracks into a stereo output."
        _add_audio_filter -p "${AMERGE_LIST}amerge=inputs=${AUDIO_TRACK_COUNT}"
        _add_audio_filter "aformat=channel_layouts=stereo"
    elif [[ "${MULTIMONO}" = true && "${1#*.}" != "mkv" ]] ; then
        _report -wt "The first two audio tracks of this non matroska file are both mono. Considering track 1 for left and track 2 for right."
        _add_audio_filter -p "[0:a:0][0:a:1]amerge=inputs=2"
        _add_audio_filter "aformat=channel_layouts=stereo"
    elif [[ "${AUDIO_CHANNELS}" -gt 2 && "${CHANNEL_LAYOUT}" != "5.1" ]] ; then
        _report -wt "The first audio track has more than 2 channels. Considering channel 1 for left and channel 2 for right and ignoring the rest."
        _add_audio_filter -p "[0:a:0]channelmap=0|1:stereo"
    else
        _add_audio_filter "aformat=channel_layouts=stereo"
    fi
    if [[ "${ADD_VOLADJ}" != "N" && "${VOLADJUST}" != "N" && "${ISOBJECT}" = "Y" ]] ; then
        if [[ -f "${INGESTLOG}" ]] ; then
            measured_I=$(_readingestlog "r128_integrated_loudness")
            measured_LRA=$(_readingestlog "r128_loudness_range")
            measured_TP=$(_readingestlog "measured_true_peak")
            measured_thresh=$(_readingestlog "measured_threshold")
            target_offset=$(_readingestlog "target_offset")
            LOUD_ADJ=$(_readingestlog "loudness_adjustment")
        fi
        if [ ! "${LOUD_ADJ}" ] ; then
            _get_volume_adjustment "${SOURCEFILE}"
        fi
        if [[ "${measured_I}" == "inf" ]] || [[ "${measured_I}" == "-inf" ]] ; then
            VOLADJUST="N"
            _report -wt "Integrated loudness for $(basename "${INPUT_MOVIE}") is ${measured_I} LUFS. Volume adjustment cannot be completed."
        else
            _report -dt "Integrated loudness for $(basename "${INPUT_MOVIE}") is ${measured_I} LUFS. Reference is -24 LUFS. Will adjust by ${LOUD_ADJ} LUFS"
            _add_audio_filter "loudnorm=measured_I=${measured_I}:measured_LRA=${measured_LRA}:measured_TP=${measured_TP}:measured_thresh=${measured_thresh}:offset=${target_offset}:linear=true:print_format=summary"
        fi
    fi
    if [[ "${PBSMIX}" = "Y" ]] ; then
         _add_audio_filter "asplit[a][b];[a]aformat=channel_layouts=stereo[stereo1];[b]aformat=channel_layouts=mono,asplit[mono1][mono2]"
         if [[ "${ADDSLATE}" != "Y" ]] ; then
             MIDDLEOPTIONS+=(-map "[stereo1]" -map "[mono1]" -map "[mono2]")
         fi
    fi
}

_get_format(){
    FORMAT="$(ffprobe -v 0 "${1}" -show_entries format=format_name -of default=nw=1:nk=1 | cut -d , -f1)"
}

_get_codectagstring(){
    CODEC_TAG_STRING=$(ffprobe "${1}" -show_streams -select_streams v:0 2> /dev/null | grep "^codec_tag_string=" | cut -d = -f 2)
    if [[ "${CODEC_TAG_STRING}" = "FFV1" ]] ; then
        FFV1_VERSION=$(ffmpeg -nostdin -debug 1 -i "${1}" -t 0.1 -f null - </dev/null 2>&1 | grep -o "ver:[0-9]*" | tail -n1 | cut -d: -f2)
    else
        FFV1_VERSION=""
    fi
}

_get_pix_fmt(){
    PIXFMT=$(ffprobe "${1}" -show_streams -select_streams v:0 2>/dev/null | grep "^pix_fmt=" | cut -d = -f 2)
}

_get_videostreamcount(){
    VIDEOSTREAMCOUNT=$(ffprobe "${1}" -select_streams v -show_entries stream=index -of flat 2>/dev/null | awk 'END { print NR }')
}

_get_audiostreamcount(){
    AUDIOSTREAMCOUNT=$(ffprobe "${1}" -select_streams a -show_entries stream=index -of flat 2>/dev/null | awk 'END { print NR }')
}

_get_timecode(){
    TIMECODE=$(ffprobe "${1}" -select_streams v -show_streams -show_format -of flat 2>/dev/null | grep "timecode=\"[0-9]" | head -n 1 | cut -d = -f 2 | sed 's/"//g')
}

_get_framerate(){
    FRAMERATE="$(ffprobe -v 0 -i "${1}" -select_streams v:0 -show_entries stream=r_frame_rate -of default=nw=1:nk=1)"
}

_get_timecode_overlay(){
    _get_timecode "${1}"
    if [[ "${TIMECODE}" ]] ; then
        TIMECODEESACPE=$(echo "${TIMECODE}" | sed 's|:|\\:|g')
    else
        TIMECODEESACPE="00\\:00\\:00;00"
    fi
    TIMECODEOVERLAY="drawtext=fontfile=/System/Library/Fonts/Monaco.dfont:timecode='${TIMECODEESACPE}':r=30000/1001:fontcolor=white:fontsize=96:shadowx=2:shadowy=2:box=1:boxcolor=gray@0.8:x=w/2-tw/2:y=h*0.8"
}

_get_timestamp_overlay(){
    TIMECODEOVERLAY="drawtext=fontfile=/System/Library/Fonts/Monaco.dfont:text=%{pts\\\:hms}:fontcolor=white:fontsize=96:shadowx=2:shadowy=2:box=1:boxcolor=gray@0.8:x=w/2-tw/2:y=h*0.8"
}

_get_info_overlay(){
    _get_framerate "${1}"
    _get_timecode "${1}"
    if [[ "${FRAMERATE}" == "30000/1001" ]] ; then
        TIMECODE="00:00:00;00"
    else
        TIMECODE="00:00:00:00"
    fi
    TIMECODEESACPE=$(echo "${TIMECODE}" | sed 's|:|\\:|g')
    INFOOVERLAY+="drawtext=fontfile=/System/Library/Fonts/Monaco.dfont:timecode='${TIMECODEESACPE}':r=${FRAMERATE}:fontcolor=white@0.8:fontsize=96:shadowx=2:shadowy=2:box=1:boxcolor=DarkGray@0.8:x=(w/2)-(tw/2):y=h*0.8"
}

_get_subtitle_overlay(){
    SUBTITLEOVERLAY="subtitles=${SUBTITLE_FILE}"
}

_get_maxdvdbitrate(){
    _get_duration "${1}"
    local DVDCAPACITY=30794400000  # in bits, minus 10%
    local CAPDVDBITRATE=6000000    # in bits/second
    MAXDVDBITRATE=$(echo "(${DVDCAPACITY} - ( ${DURATION} * 224000 )) / ${DURATION}" | bc)
    _report -dt "Data rate could be up to ${MAXDVDBITRATE}"
    if ! [[ "${MAXDVDBITRATE}" =~ ^[0-9]+$ ]] ; then
        _report -wt "Calculation of dvd bitrate failed. Evaluated to ${MAXDVDBITRATE}. Using 4000000 as bitrate instead."
        MAXDVDBITRATE=4000000
    elif [ "${MAXDVDBITRATE}" -gt "${CAPDVDBITRATE}" ] ; then
        MAXDVDBITRATE="${CAPDVDBITRATE}"
    fi
    _report -dt "Data rate for DVD is evaluated to ${MAXDVDBITRATE}"
}

_is_video(){
    # use ffmpeg's index value and stream specifier to determine if the input is a recognized as a video file by ffmpeg
    ffprobe "${1}" -show_streams -select_streams v:0 2>/dev/null | grep "^index="
}

_seconds_to_hhmmss(){
    num=$1
    h=`expr "$num" / 3600`
    m=`expr "$num"  % 3600 / 60`
    s=`expr "$num" % 60`
    printf "%02d:%02d:%02d\n" $h $m $s
}

_seconds_to_hhmmssmmm(){
    num=$1
    awk -v v1="${num}" 'BEGIN {printf "%02d:%02d:%06.3f\n", v1/3600, (v1%3600)/60, (v1%60)}'
}

_get_phase_warning(){
    INPUT="${1}"
    PHASE_ERROR="0"
    if [[ "${INPUT##*.}" = "txt" ]] ; then
        PHASETEMP="$INPUT"
    else
        PHASETEMP=$(_maketemp)
        ffprobe 2>/dev/null -f lavfi -i amovie="${INPUT}",aphasemeter=r=0.2 -select_streams 0:a:0 -show_entries frame=pkt_dts_time:frame_tags=lavfi.aphasemeter.phase -of csv > "${PHASETEMP}"
    fi
    PHASEREPORT=$(_maketemp)
    if [[ $(awk -F "," '$3<-0.18 {print $0}' "${PHASETEMP}" | wc -l | sed "s/ //g") -gt 1 ]] ; then
        PHASETEMPWARNINGS=$(_maketemp)
        _report -wt "Warning: PLEASE REVIEW. $(basename "${INPUT}") contains out of phase audio in these time ranges:"
        awk -F "," '$3<-0.18 {print $0}' "${PHASETEMP}" | cut -d "," -f 2 | cut -d "." -f 1 > "${PHASETEMPWARNINGS}"
        echo "" >> "${PHASETEMPWARNINGS}"
        while read num ; do
            if [[ -z $first ]] ; then
                first=$num; last=$num; continue;
            fi
            if [[ "$num" -ne $(($last + 5)) ]] ; then
                PHASE_ERROR="$(echo $PHASE_ERROR + 1 | bc)"
                if [[ first -eq last ]] ; then
                    _report -wn $(_seconds_to_hhmmss "${first}")
                    echo $(_seconds_to_hhmmss "${first}") >> "${PHASEREPORT}"
                    _report -wn " "
                else
                    _report -wn "$(_seconds_to_hhmmss "${first}")-$(_seconds_to_hhmmss "${last}")"
                    echo "$(_seconds_to_hhmmss "${first}")-$(_seconds_to_hhmmss "${last}")" >> "${PHASEREPORT}"
                    _report -wn " "
                fi
                first=$num; last=$num
            else
                : $((last++)) $((last++)) $((last++)) $((last++)) $((last++))
            fi

        done < "${PHASETEMPWARNINGS}"
        echo
    fi
}

_get_volume_adjustment(){
    measured_I=""
    measured_LRA=""
    measured_TP=""
    measured_thresh=""
    target_offset=""
    LOUD_ADJ=""
    LOUDNESS_OPT_START=""
    LOUDNESS_OPT_END=""
    INPUT_MOVIE="${1}"
    if [[ -n "${INTIME}" ]] ; then
        _report -dt "Loudness reading will start at intime (${INTIME})."
        LOUDNESS_OPT_START="-ss ${INTIME}"
    fi
    if [[ -n "${OUTTIME}" ]] ; then
        _report -dt "Loudness reading will end at outtime (${OUTTIME})."
        LOUDNESS_OPT_END="-to ${OUTTIME}"
    fi
    _report -dt "Getting loudness data for $(basename "${INPUT_MOVIE}") ..."
    LOUDNESS_DATA=$(ffmpeg -nostdin ${LOUDNESS_OPT_START} -i "${1}" ${LOUDNESS_OPT_END} -vn -filter_complex "${AUDIOFILTERCHAIN},loudnorm=print_format=json" -f null - 2>&1)
    VOLUME_EXIT_CODE="${?}"
    if [ "${VOLUME_EXIT_CODE}" -ne 0 ] ; then
        _report -wt "Volume analysis for ${INPUT_MOVIE} exited with ${VOLUME_EXIT_CODE}."
    else
        measured_I=$(echo "$LOUDNESS_DATA" | grep "input_i" | awk -F\" '{print $4}')
        measured_LRA=$(echo "$LOUDNESS_DATA" | grep "input_lra" | awk -F\" '{print $4}')
        measured_TP=$(echo "$LOUDNESS_DATA" | grep "input_tp" | awk -F\" '{print $4}')
        measured_thresh=$(echo "$LOUDNESS_DATA" | grep "input_thresh" | awk -F\" '{print $4}')
        target_offset=$(echo "$LOUDNESS_DATA" | grep "target_offset" | awk -F\" '{print $4}')
        LOUD_ADJ=$(echo "($measured_I - -24)*-1" | bc)
        if [[ -z "${INTIME}" ]] ; then
            _writeingestlog "measured_true_peak" "${measured_TP}"
            _writeingestlog "r128_loudness_range" "${measured_LRA}"
            _writeingestlog "r128_integrated_loudness" "${measured_I}"
            _writeingestlog "measured_threshold" "${measured_thresh}"
            _writeingestlog "target_offset" "${target_offset}"
            _writeingestlog "loudness_adjustment" "${LOUD_ADJ}"
        fi
    fi
}

_get_interlacement_full(){
    INPUT_MOVIE="${1}"

   _get_mediainfo_interlacement(){
       CONTAINER_INTERLACEMENT=$(mediainfo --inform="Video;%ScanOrder%" "${INPUT_MOVIE}")
    }

    IDET_INTERLACEMENT=$(ffmpeg -i "${INPUT_MOVIE}" -vf idet -f null -an - 2>&1 | grep "Multi frame detection:")
    echo "${IDET_INTERLACEMENT}"
    IDET_SUMMARY=$(echo "${IDET_INTERLACEMENT}" | cut -d: -f2- | awk '{print $1 " " $2 "\n" $3 " " $4 "\n" $5 " " $6 "\n" $7 " " $8}')
    echo "${IDET_SUMMARY}"
    IDET_TOP=$(echo "${IDET_INTERLACEMENT}" | cut -d: -f2- | awk '{print $1 " " $2 "\n" $3 " " $4 "\n" $5 " " $6 "\n" $7 " " $8}' | sort -n -k2 | tail -n1 | cut -d: -f1)
    echo "${IDET_TOP}"
    echo "Testing with ffmpeg says this file is ${IDET_TOP}"
    _get_mediainfo_interlacement
    echo "Media Info says this file is ${CONTAINER_INTERLACEMENT}"
    if [ -z "${CONTAINER_INTERLACEMENT}" ] ; then
        _report -qn "MediaInfo can't test the interlacement of this file. Please consider using the results from the ffmpeg file test."
    fi
    if [[ "${CONTAINER_INTERLACEMENT}" = "${IDET_TOP}" ]] ; then
        if [[ "${IDET_TOP}" = "TFF" ]] ; then
            echo "The frames in the input file are majority top field first."
            _writeingestlog "filter choice" "setfield=tff"
        fi
        if [[ "${IDET_TOP}" = "BFF" ]] ; then
            echo "The frames in the input file are majority bottom field first."
            _writeingestlog "filter choice" "setfield=bff"
        fi
        if [[ "${IDET_TOP}" = "Progressive" ]] ; then
            echo "The frames in the input file are majority progressive."
            _writeingestlog "filter choice" "setfield=prog"
        fi
    fi
    if [[ "${CONTAINER_INTERLACEMENT}" != "${IDET_TOP}" ]] ; then
        _report -q "Which video filter do you want to use? "
        PS3="Selection? "
        select FILTERCHOICE in "TFF" "BFF" "Progressive" ; do
            break
        done
        if [[ "${FILTERCHOICE}" = "TFF" ]] ; then
            _writeingestlog "filter choice" "setfield=tff"
        fi
        if [[ "${FILTERCHOICE}" = "BFF" ]] ; then
            _writeingestlog "filter choice" "setfield=bff"
        fi
        if [[ "${FILTERCHOICE}" = "Progressive" ]] ; then
            _writeingestlog "filter choice" "setfield=prog"
        fi
    fi
}

_get_cropdetection(){
    INPUT_MOVIE="${1}"
    _report -dt "Getting cropping data for $(basename "${INPUT_MOVIE}") ..."
    CROP_DATA=$(ffmpeg -i "${INPUT_MOVIE}" -an -filter_complex cropdetect -f null - 2>&1 | grep -o "crop=[0-9:]*")
    CROP_ERR="${?}"
    [ "${CROP_ERR}" -ne 0 ] && { _report -wt "Crop detection analysis for ${INPUT_MOVIE} exited with ${CROP_ERR}." ; exit ;};
    for i in $(echo "${CROP_DATA}") ; do
        [ "$i" != "" ] && CROPADJ="$i"
    done
    _report -dt "Crop detection complete. Will crop by ${CROPADJ} (width,height,from_left,from_top) before scaling."
}

_free_space(){
    #this should give the free space in gigabytes
    local SPACE="${1}"  #This value represents the space in gigabytes required for the script to run
    local OUTPUTDIR="${2}"
    if [ ! -d "${OUTPUTDIR}" ] ; then
        _report -wt "The output directory [${OUTPUTDIR}] that free-space function is seeking does not exist."
        exit 1
    fi
    [[ ! "${SPACE}" =~ ^-?[0-9]+$ ]] && { _report -wt "Number is not an integer." ; exit 1 ;};
    FREESPACE=$(df -g "${OUTPUTDIR}" | awk '{ print $4; }' | tail -n 1)
    if [ "${FREESPACE}" -lt "${SPACE}" ] ; then
      _report -wts "ERROR only ${FREESPACE} gb free in this directory. This script requires at least ${SPACE} gigabytes"
      _writeerrorlog "_free_space" "There is only ${FREESPACE} gb free in this directory. This script requires at least ${SPACE} gigabytes to run."
      exit 1
    fi
}

_summarize_make(){
    _report -dt "$(basename "${OUTPUT}") is done."
}

_prep_ffmpeg_log(){
    OPTIND=1
    while getopts ":q" OPT ; do
        case "${OPT}" in
            q) NOLOG="Y";;
            :) echo "Option -${OPTARG} requires an argument" ; exit 1 ;;
            *) echo "Bad option -${OPTARG}" ; _usage ;;
        esac
    done
    shift $(( ${OPTIND} - 1 ))
    if [ "${LOGDIR}" != "" ] ; then
        _mkdir2 "${LOGDIR}"
        if [ "${NOLOG}" = "Y" ] ; then
            _unset_ffreport
        else
            if [[ -n "${OUTPUT_TYPE}" ]] ;then
                export FFREPORT="file=${LOGDIR}/%p_%t_$(basename "${0}")_${OUTPUT_TYPE}_${VERSION}.txt:level=32"
            else
                export FFREPORT="file=${LOGDIR}/%p_%t_$(basename "${0}")_${VERSION}.txt:level=32"
            fi
        fi
        INPUTOPTIONS+=(-v info)
        INPUTOPTIONS+=(-hide_banner)
        INPUTOPTIONS+=(-stats)
    else
        _unset_ffreport
    fi
}

_emailoutcome(){
    # fail only at the moment
    MESSAGETEMPFILE=$(_maketemp)
    echo -e "To: ${EMAIL_OUTCOME_TO}" > "${MESSAGETEMPFILE}"
    echo -e "Subject: ${PACKAGE} failed during ${SCRIPTNAMESHORT}" >> "${MESSAGETEMPFILE}"
    echo -e ":(" >> "${MESSAGETEMPFILE}"
    sendmail -t < "${MESSAGETEMPFILE}"
    rm -f "${MESSAGETEMPFILE}"
}

_get_filesystem(){
    if [ -f "${1}" -o -d "${1}" ] ; then
        df "${1}" | tail -n1 | cut -d " " -f1
    else
        _report -wt "_get_filesystem was expecting a file or directory but got a ${1}"
    fi
}

_set_accesstimes(){
    # set in and out times if used
    if [[ -f "${INGESTLOG}" && "${ISOBJECT}" = "Y" ]] ; then
        INTIME=$(_readingestlog "intime")
        OUTTIME=$(_readingestlog "outtime")
        if [[ "${INTIME}" ]] ; then
            _report -dt "ATTENTION: Transcoding will use intime (${INTIME}) during transcoding."
            INPUTOPTIONS+=(-seek_timestamp 1)
            MIDDLEOPTIONS+=(-ss "${INTIME}")
        fi
        if [[ "${OUTTIME}" ]] ; then
            _report -dt "ATTENTION: Transcoding will use outtime (${OUTTIME}) during transcoding."
            MIDDLEOPTIONS+=(-to "${OUTTIME}")
        fi
    fi
}

_set_up_output(){
    # set up output
    _log -b
    if [[ -n "${OUTPUTNAME_FORCED}" ]] ; then
        OUTPUT="${OUTPUTDIR}/${OUTPUTNAME_FORCED}"
    else
        OUTPUT="${OUTPUTDIR}/${MEDIAID%.*}${SUFFIX}.${EXTENSION}"
    fi
    if [ -s "${OUTPUT}" ] ; then
        _report -wt "WARNING ${OUTPUT} already exists, skipping transcode"
        continue
    fi
    _mkdir2 "${OUTPUTDIR}"
}

_filter_to_middle_option(){
    if [ -n "${VIDEOFILTERCHAIN}" -a -n "${AUDIOFILTERCHAIN}" ] ; then
        MIDDLEOPTIONS+=(-filter_complex "${VIDEOFILTERCHAIN};${AUDIOFILTERCHAIN}")
    elif [ -n "${VIDEOFILTERCHAIN}" ] ; then
        MIDDLEOPTIONS+=(-filter_complex "${VIDEOFILTERCHAIN}")
    elif [ -n "${AUDIOFILTERCHAIN}" ] ; then
        MIDDLEOPTIONS+=(-filter_complex "${AUDIOFILTERCHAIN}")
    fi
}

_unset_variables(){
    unset INPUTOPTIONS
    unset MIDDLEOPTIONS
    unset MULTIMONO
    unset FIRSTMONO
    unset VIDEOFILTERCHAIN
    unset AUDIOFILTERCHAIN
    unset MIDDLEOPTIONSXDCAM
    unset MIDDLEOPTIONSIMX
    unset INPUTOPTIONSFRAMEMD5
    unset EXTRAOUTPUTS
}

_pashua_run() {
    # Wrapper function for interfacing to Pashua. Written by Carsten
    # Bluem <carsten@bluem.net> in 10/2003, modified in 12/2003 (including
    # a code snippet contributed by Tor Sigurdsson), 08/2004 and 12/2004.
    # Write config file

    # Find Pashua binary. We do search both . and dirname "${0}"
    # , as in a doubleclickable application, cwd is /
    # BTW, all these quotes below are necessary to handle paths
    # containing spaces.
    BUNDLEPATH="Pashua.app/Contents/MacOS/Pashua"
    MYPATH=$(dirname "${0}")
    for SEARCHPATH in "${MYPATH}/Pashua" "${MYPATH}/${BUNDLEPATH}" "./${BUNDLEPATH}" \
                      "/Applications/${BUNDLEPATH}" "${HOME}/Applications/${BUNDLEPATH}"
    do
        if [ -f "${SEARCHPATH}" -a -x "${SEARCHPATH}" ] ; then
            PASHUAPATH=${SEARCHPATH}
            break
        fi
    done
    if [ ! "${PASHUAPATH}" ] && [[ "$(uname -s)" = "Darwin" ]] ; then
        echo "Error: Pashua is used to edit but is not found."
        if [[ "${PASHUAINSTALL}" = "" ]] ; then
            echo "Attempting to run: brew cask install pashua"
            if [[ "${PASHUAINSTALL}" != "Y" ]] && [[ "${PASHUAFAIL}" != "Y" ]] ; then
                brew cask install pashua && PASHUAINSTALL="Y" || PASHUAFAIL=Y
                _pashua_run
            fi
        fi
    else
        ENCODING=""

        # Get result
        RESULT=$("${PASHUAPATH}" ${ENCODING} ${PASHUA_CONFIGFILE} | sed 's/ /;;;/g')

        # Parse result
        for LINE in ${RESULT} ; do
            KEY=$(echo ${LINE} | sed 's/^\([^=]*\)=.*$/\1/')
            VALUE=$(echo ${LINE} | sed 's/^[^=]*=\(.*\)$/\1/' | sed 's/;;;/ /g')
            VARNAME="${KEY}"
            VARVALUE="${VALUE}"
            eval $VARNAME='$VARVALUE'
        done
    fi
} # _pashua_run()
